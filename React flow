package com.example.healthcheck;

import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.FileTime;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Comparator;
import java.util.Optional;

@Slf4j
@Component
public class SftpHealthChecker {

    private final Path incomingDir = Paths.get("/nas/incoming/");
    private final Path processedDir = Paths.get("/nas/processed/");
    private static final long SLA_MINUTES = 30;

    @Scheduled(fixedRate = 30 * 60 * 1000) // every 30 minutes
    public void checkSftpHealth() throws IOException {

        // 1️⃣ Get oldest file in incoming
        Optional<Path> oldestIncomingOpt = Files.list(incomingDir)
                .filter(Files::isRegularFile)
                .min(Comparator.comparingLong(p -> {
                    try {
                        return Files.getLastModifiedTime(p).toMillis();
                    } catch (IOException e) {
                        return Long.MAX_VALUE;
                    }
                }));

        if (oldestIncomingOpt.isEmpty()) {
            log.info("HEALTH OK – Incoming folder empty, nothing pending.");
            return;
        }

        Path oldestIncoming = oldestIncomingOpt.get();
        LocalDateTime incomingTime = toLocal(Files.getLastModifiedTime(oldestIncoming));

        // 2️⃣ Get latest processed file
        Optional<Path> latestProcessedOpt = Files.list(processedDir)
                .filter(Files::isRegularFile)
                .max(Comparator.comparingLong(p -> {
                    try {
                        return Files.getLastModifiedTime(p).toMillis();
                    } catch (IOException e) {
                        return Long.MIN_VALUE;
                    }
                }));

        if (latestProcessedOpt.isEmpty()) {
            log.error("❌ SFTP FAILURE – No processed files found while incoming has files. " +
                      "Script/SFTP may not be running.");
            return;
        }

        Path latestProcessed = latestProcessedOpt.get();
        LocalDateTime processedTime = toLocal(Files.getLastModifiedTime(latestProcessed));

        // 3️⃣ Compute time lag
        long lagMinutes = Duration.between(processedTime, incomingTime).toMinutes();

        if (lagMinutes > SLA_MINUTES) {
            log.error("❌ SFTP FAILURE – Pipeline stuck. " +
                    "Oldest incoming file '{}' is {} minutes older than latest processed file '{}'. " +
                    "This exceeds SLA of {} minutes.",
                    oldestIncoming.getFileName(), lagMinutes,
                    latestProcessed.getFileName(), SLA_MINUTES);
        } else {
            log.info("✔ SFTP OK – Oldest incoming lag: {} minutes (within SLA {} mins). " +
                     "Latest processed file: {}, Oldest incoming: {}",
                    lagMinutes, SLA_MINUTES,
                    latestProcessed.getFileName(), oldestIncoming.getFileName());
        }
    }

    private LocalDateTime toLocal(FileTime ft) {
        return LocalDateTime.ofInstant(ft.toInstant(), ZoneId.systemDefault());
    }
}
