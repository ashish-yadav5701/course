import { useEffect, useRef, useState } from "react";

// Sitting frame + walking frames
const sittingFrame = "/assets/bot/sit.png";
const walkingFrames = [
  "/assets/bot/walk1.png",
  "/assets/bot/walk2.png",
  "/assets/bot/walk3.png",
  "/assets/bot/walk4.png",
  "/assets/bot/walk5.png",
];

export default function WalkingBot() {
  const botRef = useRef(null);

  // Walking state
  const [walking, setWalking] = useState(false);

  // Which frame to show (walking only)
  const [frameIndex, setFrameIndex] = useState(0);

  // Current direction
  const [direction, setDirection] = useState("right");

  // ---------------- INACTIVITY LOGIC ----------------
  useEffect(() => {
    let timer;

    const resetTimer = () => {
      clearTimeout(timer);
      setWalking(false); // user is active â†’ sit
      if (botRef.current) {
        botRef.current.style.transform = "translateX(0px) scaleX(1)";
      }
      timer = setTimeout(() => setWalking(true), 10000); // start walking after 10s
    };

    resetTimer();

    const events = ["mousemove", "keydown", "click", "touchstart"];
    events.forEach(ev =>
      window.addEventListener(ev, resetTimer)
    );

    return () => {
      events.forEach(ev =>
        window.removeEventListener(ev, resetTimer)
      );
      clearTimeout(timer);
    };
  }, []);

  // ---------------- WALKING FRAME ANIMATION ----------------
  useEffect(() => {
    if (!walking) return;

    const interval = setInterval(() => {
      setFrameIndex(prev => (prev + 1) % walkingFrames.length);
    }, 120);

    return () => clearInterval(interval);
  }, [walking]);

  // ---------------- MOVEMENT INSIDE PARENT ----------------
  useEffect(() => {
    if (!walking) return;

    let x = 0;
    const speed = 2;
    let animationId;

    const step = () => {
      const parent = botRef.current?.parentElement;
      if (!parent) return;

      const parentWidth = parent.clientWidth;
      const maxX = parentWidth - 20; // <-- your requirement

      if (direction === "right") {
        x += speed;
        if (x >= maxX) setDirection("left");
      } else {
        x -= speed;
        if (x <= 0) setDirection("right");
      }

      // Apply movement + horizontal flip
      botRef.current.style.transform =
        `translateX(${x}px) scaleX(${direction === "right" ? 1 : -1})`;

      animationId = requestAnimationFrame(step);
    };

    animationId = requestAnimationFrame(step);

    return () => cancelAnimationFrame(animationId);
  }, [walking, direction]);

  return (
    <div
      ref={botRef}
      style={{
        width: 80,
        height: 80,
        position: "absolute",
        top: 0,
        left: 0,
        backgroundImage: walking
          ? `url(${walkingFrames[frameIndex]})`
          : `url(${sittingFrame})`,
        backgroundSize: "contain",
        backgroundRepeat: "no-repeat",
        pointerEvents: "none",
        transition: "opacity 0.3s ease",
      }}
    />
  );
}
