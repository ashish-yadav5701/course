package com.example.healthcheck;

import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.FileTime;
import java.time.*;
import java.util.Comparator;
import java.util.Optional;

@Slf4j
@Component
public class SftpHealthChecker {

    // Directories
    private final Path incomingDir = Paths.get("/nas/incoming/");
    private final Path processedDir = Paths.get("/nas/processed/");

    // Time thresholds
    private static final long COOL_OFF_MIN = 2;        // Ignore files younger than 2 minutes
    private static final long SLA_MIN = 10;            // Stall detection threshold
    private static final long ABS_THRESHOLD_MIN = 60;  // Anomaly threshold (abs gap > 60 mins)

    @Scheduled(fixedRate = 30 * 60 * 1000) // every 30 minutes
    public void checkSftpHealth() throws IOException {

        LocalDateTime now = LocalDateTime.now();

        // ---------------------------------------------------------
        // STEP 1: Find oldest eligible incoming file (> cool-off)
        // ---------------------------------------------------------
        Optional<Path> oldestIncomingOpt = Files.list(incomingDir)
                .filter(Files::isRegularFile)
                .filter(p -> {
                    try {
                        LocalDateTime lastMod = toLocal(Files.getLastModifiedTime(p));
                        long age = Duration.between(lastMod, now).toMinutes();
                        return age > COOL_OFF_MIN;  // only eligible files
                    } catch (Exception e) {
                        return false;
                    }
                })
                .min(Comparator.comparingLong(p -> {
                    try {
                        return Files.getLastModifiedTime(p).toMillis();
                    } catch (Exception e) {
                        return Long.MAX_VALUE;
                    }
                }));

        // ------------------------------
        // CASE A: Incoming empty OR only fresh files → Healthy
        // ------------------------------
        if (oldestIncomingOpt.isEmpty()) {
            log.info("HEALTH OK – Incoming folder empty or all files within cool-off ({} min).", COOL_OFF_MIN);
            return;
        }

        Path oldestIncoming = oldestIncomingOpt.get();
        LocalDateTime incomingOldestTime = toLocal(Files.getLastModifiedTime(oldestIncoming));
        long incomingAge = Duration.between(incomingOldestTime, now).toMinutes();

        // ---------------------------------------------------------
        // STEP 2: Get processed directory mtime
        // ---------------------------------------------------------
        LocalDateTime processedMTime;
        try {
            FileTime ft = Files.getLastModifiedTime(processedDir);
            processedMTime = toLocal(ft);
        } catch (Exception e) {
            processedMTime = null;
        }

        // ------------------------------
        // CASE B: Processed empty but incoming has eligible files
        // ------------------------------
        if (processedMTime == null) {

            if (incomingAge > SLA_MIN) {
                log.error("❌ SFTP FAILURE – Processed folder inactive and oldest incoming '{}' "
                        + "age {} minutes (> SLA {} min).",
                        oldestIncoming.getFileName(), incomingAge, SLA_MIN);
            } else {
                log.info("⏳ Within SLA – Processed empty but oldest incoming '{}' age {} min.",
                        oldestIncoming.getFileName(), incomingAge);
            }

            return;
        }

        // ---------------------------------------------------------
        // STEP 3: Both incoming & processed active → Compute lag
        // ---------------------------------------------------------
        long rawDiff = Duration.between(processedMTime, incomingOldestTime).toMinutes();

        // Clamped lag for SLA detection (stall detection)
        long clampedLag = Math.max(0, rawDiff);

        // Absolute gap for anomaly detection
        long absGap = Math.abs(rawDiff);

        // ------------------------------
        // Stall Detection (SLA Check)
        // ------------------------------
        if (clampedLag > SLA_MIN) {
            log.error("❌ SFTP FAILURE – Pipeline stalled. Oldest incoming '{}' is {} minutes "
                    + "behind processed folder mtime (SLA {} min).",
                    oldestIncoming.getFileName(), clampedLag, SLA_MIN);
            return;
        }

        // ------------------------------
        // Anomaly Detection (large negative or positive gaps)
        // ------------------------------
        if (absGap > ABS_THRESHOLD_MIN) {
            log.warn("⚠ ANOMALY – Absolute gap of {} minutes between incoming '{}' and processed folder. "
                    + "Check clock sync, manual deletions, or abnormal delays. Threshold={} min.",
                    absGap, oldestIncoming.getFileName(), ABS_THRESHOLD_MIN);
            // Don't fail — anomaly only
        }

        // ------------------------------
        // CASE D: Everything within thresholds → Healthy
        // ------------------------------
        log.info("✔ SFTP OK – clampedLag={} min (<= SLA {} min). absGap={} min (<= {} min). "
                        + "Oldest incoming='{}', processed mtime={}",
                clampedLag, SLA_MIN,
                absGap, ABS_THRESHOLD_MIN,
                oldestIncoming.getFileName(), processedMTime);
    }

    private LocalDateTime toLocal(FileTime ft) {
        return LocalDateTime.ofInstant(ft.toInstant(), ZoneId.systemDefault());
    }
}
