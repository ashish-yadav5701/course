package com.example.healthcheck;

import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.FileTime;
import java.time.*;
import java.util.Comparator;
import java.util.Optional;

@Slf4j
@Component
public class SftpHealthChecker {

    private final Path incomingDir = Paths.get("/nas/incoming/");
    private final Path processedDir = Paths.get("/nas/processed/");

    private static final long COOL_OFF_MIN = 2;
    private static final long SLA_MIN = 10;

    @Scheduled(fixedRate = 30 * 60 * 1000)
    public void checkSftpHealth() throws IOException {

        LocalDateTime now = LocalDateTime.now();

        // ---------------------------------------------------------
        // 1️⃣ Find oldest eligible file in INCOMING (> cool-off)
        // ---------------------------------------------------------
        Optional<Path> oldestEligibleIncomingOpt =
                Files.list(incomingDir)
                     .filter(Files::isRegularFile)
                     .filter(p -> {
                         try {
                             LocalDateTime lastMod = toLocal(Files.getLastModifiedTime(p));
                             long age = Duration.between(lastMod, now).toMinutes();
                             return age > COOL_OFF_MIN; 
                         } catch (Exception e) {
                             return false;
                         }
                     })
                     .min(Comparator.comparingLong(p -> {
                         try { return Files.getLastModifiedTime(p).toMillis(); }
                         catch (Exception e) { return Long.MAX_VALUE; }
                     }));

        // ------------------------------
        // CASE A: Incoming is empty
        // ------------------------------
        if (oldestEligibleIncomingOpt.isEmpty()) {
            log.info("HEALTH OK – Incoming folder empty or all files within cool-off.");
            return;
        }

        Path oldestIncoming = oldestEligibleIncomingOpt.get();
        LocalDateTime incomingOldestTime = toLocal(Files.getLastModifiedTime(oldestIncoming));

        // ---------------------------------------------------------
        // 2️⃣ Check processed directory mtime
        // ---------------------------------------------------------
        LocalDateTime processedMTime;
        try {
            FileTime ft = Files.getLastModifiedTime(processedDir);
            processedMTime = toLocal(ft);
        } catch (Exception e) {
            processedMTime = null;
        }

        // ------------------------------
        // CASE C: Processed dir empty (or never written) but incoming has eligible files
        // ------------------------------
        if (processedMTime == null) {

            long incomingAge = Duration.between(incomingOldestTime, now).toMinutes();

            if (incomingAge > SLA_MIN) {
                log.error("❌ SFTP FAILURE – Processed folder has no activity & oldest incoming '{}' "
                        + "is {} minutes old (> SLA {} min).",
                        oldestIncoming.getFileName(), incomingAge, SLA_MIN);
            } else {
                log.info("⏳ Within SLA – Processed empty but incoming '{}' age {} min.",
                        oldestIncoming.getFileName(), incomingAge);
            }
            return;
        }

        // ------------------------------
        // CASE D: Both incoming & processed active
        // ------------------------------
        long lag = Duration.between(processedMTime, incomingOldestTime).toMinutes();

        // handle negative lag
        if (lag < 0) lag = 0;

        if (lag > SLA_MIN) {
            log.error("❌ SFTP FAILURE – Lag {} min > SLA {} min. Oldest incoming: '{}', processed folder mtime: {}.",
                    lag, SLA_MIN, oldestIncoming.getFileName(), processedMTime);
        } else {
            log.info("✔ SFTP OK – Lag {} min (≤ SLA {}). Oldest incoming='{}', processed mtime={}",
                    lag, SLA_MIN, oldestIncoming.getFileName(), processedMTime);
        }
    }

    private LocalDateTime toLocal(FileTime ft) {
        return LocalDateTime.ofInstant(ft.toInstant(), ZoneId.systemDefault());
    }
}
